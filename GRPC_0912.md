# Google RPC

## 使用 Protocol Buffer
一个类似于JSON的serialized structured data

* 用于定义结构化的数据，编译之后会生成相应类，方便语言访问
* grpc 的message 的payload 就由PB 定义

## write service 
* gRPC将service的interface 也定义在 proto 文件中
	* service 可以是双向single message, 也可以是有stream（包括双向stream）
	* 编译之后就有了service的 API interface, 我们只需要在 client调用，在server端实现   （这个实现的细节还不知道）

## RPC 运行  
* 第一个packet 用于传metadata, deadline 等 (在发第一个request之前)
* gRPC 设置了deadline， 超时会raise error 

## Q: 
* Channel   基于HTTP/2 实现   [HTTP/2参考](https://ye11ow.gitbooks.io/http2-explained/content/)   但是为什么是基于HTTP/2 实现的？  按照它的说法，不应该是一个在transport level 之上的protocol么

## 尝试gRPC (python)   [参照QuickStart](http://www.grpc.io/docs/quickstart/python.html#update-the-server)
* install grpcio
	* 注意 OS X 需要  --ignore-installed 
* install grpc tools    protoc 等
* Run  (server, client)
* Write   有些细节还不太清楚     [参照tutorial](http://www.grpc.io/docs/tutorials/basic/python.html#request-streaming-rpc)
	* 配置protocs 
		* 写service  -> 写methods   rpc xxxx(xx) returns (stream xxx) {} 
		* 定义相关的 request 和 reply 类型
		```
		message Point{
			int32 ... = .; 
		}
		```
	* 使用工具生成 server, client 端的代码 (相应的Interface Class 已经生成好了)
		* 生成了几个类
		* xxxstub  client通过它invoke RPC
		* xxxservicer server通过继承他来增加RPC method的实现
		* add_xxxServicer_to_server   增添servicer 都 server 类中  (运行这个servicer) 
	* 写 server, client  (设置channel， 产生stub等还是不太清楚)
	* 写server code, then start server:
		* 继承protocs 产生的servicer 类
		* stream: 使用生成器来写  (这段具体还不太清楚)
		* start server: (有一点没看懂的)
			```
			def serve():
  				server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
  				route_guide_pb2.add_RouteGuideServicer_to_server(
      				RouteGuideServicer(), server)
  				server.add_insecure_port('[::]:50051')
  				server.start()
			```
		* 写 client:
			* 设置 channel
			* stub调用rpc， 针对single 或 stream的replies， 应该有不同的处理
	* 


## Ref


